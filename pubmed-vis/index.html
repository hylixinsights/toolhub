<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PubMed Network Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600&family=DM+Sans:wght@300;400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0b;
            --bg-secondary: #111113;
            --bg-card: #18181b;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #52525b;
            --accent: #e4c9a3;
            --accent-glow: rgba(228, 201, 163, 0.15);
            --line-color: #27272a;
            --border-subtle: #27272a;
            --error-bg: rgba(220, 38, 38, 0.1);
            --error-text: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 50% 0%, #1f2833 0%, #0b0c10 70%);
            /* Subtle blueish tint at top like index */
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
            padding-top: 40px;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 3.5rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 300;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .developer-credit {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .developer-credit a {
            color: var(--accent);
            text-decoration: none;
            transition: all 0.3s;
        }

        .developer-credit a:hover {
            color: var(--text-primary);
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .upload-section {
            background: var(--bg-secondary);
            border: 1px dashed var(--border-subtle);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            margin-bottom: 40px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .upload-section:hover {
            border-color: var(--accent);
            background: var(--accent-glow);
            transform: translateY(-2px);
        }

        .upload-section.dragover {
            border-color: var(--accent);
            background: var(--accent-glow);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            filter: grayscale(100%);
            opacity: 0.7;
            transition: all 0.3s;
        }

        .upload-section:hover .upload-icon {
            filter: grayscale(0%);
            opacity: 1;
        }

        .upload-section h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        #fileInput {
            display: none;
        }

        .upload-btn {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            font-family: 'DM Sans', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .upload-btn:hover {
            background: var(--accent);
            color: var(--bg-primary);
            box-shadow: 0 0 20px var(--accent-glow);
        }

        /* Network Section */
        .network-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 1px;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            color: var(--text-muted);
            font-family: 'DM Sans', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .network-container {
            display: none;
        }

        .network-container.active {
            display: block;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .controls {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            border: 1px solid var(--border-subtle);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            max-width: 300px;
        }

        .search-input {
            width: 100%;
            padding: 10px 35px 10px 14px;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            font-size: 0.9rem;
            background: var(--bg-card);
            color: var(--text-primary);
            transition: all 0.3s;
            font-family: 'DM Sans', sans-serif;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 1px var(--accent-glow);
        }

        .search-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            pointer-events: none;
            font-size: 0.8rem;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            margin-top: 5px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            padding: 10px 14px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            transition: background 0.2s;
            font-size: 0.9rem;
        }

        .search-result-item:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .no-results {
            padding: 15px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        select,
        input[type="range"] {
            padding: 8px 12px;
            border: 1px solid var(--border-subtle);
            border-radius: 6px;
            font-size: 0.9rem;
            background: var(--bg-card);
            color: var(--text-primary);
            font-family: 'DM Sans', sans-serif;
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
        }

        input[type="range"] {
            width: 100px;
            accent-color: var(--accent);
            padding: 0;
            height: 4px;
            background: var(--border-subtle);
            border: none;
            border-radius: 2px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: #d4b890;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border-color: var(--border-subtle);
        }

        .btn-secondary:hover {
            border-color: var(--text-secondary);
            color: var(--text-primary);
        }

        .btn-clear {
            background: rgba(220, 38, 38, 0.1);
            color: #f87171;
            border: 1px solid rgba(220, 38, 38, 0.2);
        }

        .btn-clear:hover {
            background: rgba(220, 38, 38, 0.2);
            border-color: #f87171;
        }

        /* SVG Container */
        .svg-container {
            width: 100%;
            height: 700px;
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            background: var(--bg-secondary);
            overflow: hidden;
            position: relative;
        }

        /* Stats & Legend */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border-subtle);
            transition: all 0.3s;
        }

        .stat-card:hover {
            border-color: var(--accent);
            transform: translateY(-3px);
        }

        .stat-value {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .legend {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
        }

        .legend-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--bg-primary);
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 2000;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip strong {
            color: var(--accent);
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.2rem;
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .tooltip-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* D3 Elements */
        .node {
            cursor: pointer;
            stroke: var(--bg-primary);
            stroke-width: 1.5px;
            transition: opacity 0.2s;
        }

        .node.highlighted {
            stroke: var(--accent);
            stroke-width: 3px;
        }

        .node.faded {
            opacity: 0.1;
        }

        .link {
            stroke: var(--line-color);
            stroke-opacity: 0.4;
            transition: opacity 0.2s;
        }

        .link.highlighted {
            stroke: var(--accent);
            stroke-width: 2px;
            stroke-opacity: 0.8;
        }

        .link.faded {
            opacity: 0.05;
        }

        svg text {
            font-family: 'DM Sans', sans-serif;
            fill: var(--text-muted);
            pointer-events: none;
            text-anchor: middle;
            font-size: 10px;
            opacity: 0.8;
        }

        svg text.highlighted {
            fill: var(--text-primary);
            font-weight: bold;
            font-size: 12px;
            opacity: 1;
        }

        svg text.faded {
            opacity: 0.1;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 50px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid var(--bg-secondary);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .error {
            background: var(--error-bg);
            color: var(--error-text);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            border: 1px solid rgba(220, 38, 38, 0.3);
            text-align: center;
        }

        .error.active {
            display: block;
        }

        footer {
            margin-top: 60px;
            padding: 30px;
            text-align: center;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        footer a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: 0.2s;
        }

        footer a:hover {
            color: var(--accent);
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>PubMed Network Visualizer</h1>
            <p class="subtitle">Visualize paper-MeSH and co-authorship networks</p>
            <p class="developer-credit">Developed by Helder Nakaya (<a href="https://csbiology.org"
                    target="_blank">CSBL</a>)</p>
        </header>

        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÅ</div>
                <h2>Upload PubMed Data</h2>
                <p style="margin: 15px 0; color: var(--text-secondary);">Drag and drop your PubMed text file here</p>
                <input type="file" id="fileInput" accept=".txt" />
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
                <p style="margin-top: 20px; font-size: 0.8rem; color: var(--text-muted);">Supports .txt files</p>
            </div>

            <div class="error" id="errorMsg"></div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p style="color: var(--text-secondary);">Processing data...</p>
            </div>

            <div id="networkSection" style="display: none;">
                <div class="network-tabs">
                    <button class="tab active" onclick="switchNetwork('paper-mesh')">Paper-MeSH</button>
                    <button class="tab" onclick="switchNetwork('coauthorship')">Co-authorship</button>
                </div>

                <!-- Paper-MeSH Container -->
                <div id="paper-mesh" class="network-container active">
                    <div class="controls">
                        <div class="search-container">
                            <input type="text" class="search-input" id="searchPaperMesh"
                                placeholder="Search nodes..." />
                            <span class="search-icon">üîç</span>
                            <div class="search-results" id="searchResultsPaperMesh"></div>
                        </div>
                        <div class="control-group"><label>Size:</label><input type="range" id="nodeSizePaperMesh"
                                min="3" max="15" value="8"><span id="nodeSizeValuePM"
                                style="color:var(--text-secondary); font-size:0.9rem;">8</span></div>
                        <div class="control-group"><label>Layout:</label><select id="layoutPaperMesh">
                                <option value="force">Force</option>
                                <option value="circular">Circular</option>
                            </select></div>
                        <button class="btn btn-primary" onclick="resetZoom('paper-mesh')">Reset</button>
                        <button class="btn btn-clear" onclick="clearSelection('paper-mesh')">Clear</button>
                        <button class="btn btn-secondary" onclick="downloadNetwork('paper-mesh')">Excel</button>
                    </div>
                    <div class="svg-container"><svg id="svgPaperMesh" width="100%" height="100%"></svg></div>
                    <div class="legend">
                        <div class="legend-title">Legend</div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e4c9a3;"></div><span>Journals/Papers (Click to
                                view PubMed)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #a78bfa;"></div><span>MeSH Terms</span>
                        </div>
                    </div>
                    <div class="stats" id="statsPaperMesh"></div>
                </div>

                <!-- Co-authorship Container -->
                <div id="coauthorship" class="network-container">
                    <div class="controls">
                        <div class="search-container">
                            <input type="text" class="search-input" id="searchCoauthorship"
                                placeholder="Search authors..." />
                            <span class="search-icon">üîç</span>
                            <div class="search-results" id="searchResultsCoauthorship"></div>
                        </div>
                        <div class="control-group"><label>Size:</label><input type="range" id="nodeSizeCoauthorship"
                                min="3" max="15" value="8"><span id="nodeSizeValueCA"
                                style="color:var(--text-secondary); font-size:0.9rem;">8</span></div>
                        <div class="control-group"><label>Layout:</label><select id="layoutCoauthorship">
                                <option value="force">Force</option>
                                <option value="circular">Circular</option>
                            </select></div>
                        <div class="control-group"><label>Min Collab:</label><input type="range" id="minWeight" min="1"
                                max="10" value="1"><span id="minWeightValue"
                                style="color:var(--text-secondary); font-size:0.9rem;">1</span></div>
                        <button class="btn btn-primary" onclick="resetZoom('coauthorship')">Reset</button>
                        <button class="btn btn-clear" onclick="clearSelection('coauthorship')">Clear</button>
                        <button class="btn btn-secondary" onclick="downloadNetwork('coauthorship')">Excel</button>
                    </div>
                    <div class="svg-container"><svg id="svgCoauthorship" width="100%" height="100%"></svg></div>
                    <div class="legend">
                        <div class="legend-title">Communities</div>
                        <div id="communityLegend"
                            style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px;">
                        </div>
                    </div>
                    <div class="stats" id="statsCoauthorship"></div>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>
        <footer>
            <p>Interactive Visualization ‚Ä¢ Hover to preview ‚Ä¢ Click to lock ‚Ä¢ Drag to move</p>
            <p style="margin-top: 10px;"><a href="../index.html">‚Üê Back to Tool Hub</a></p>
        </footer>
    </div>

    <script>
        let paperMeshNetwork = null, coauthorshipNetwork = null;
        let paperMeshSimulation = null, coauthorshipSimulation = null;
        let currentNodeSize = { 'paper-mesh': 8, 'coauthorship': 8 };
        let selectedNode = { 'paper-mesh': null, 'coauthorship': null };

        // Updated Colors for Dark Theme
        const journalColor = '#e4c9a3'; // Gold Accent
        const meshColor = '#a78bfa';    // Light Purple
        const communityColors = [
            '#f87171', '#fbbf24', '#34d399', '#60a5fa',
            '#818cf8', '#a78bfa', '#f472b6', '#fb7185',
            '#2dd4bf', '#a3e635', '#fcd34d'
        ]; // Bright distinct colors

        document.getElementById('fileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) processFile(file);
        });

        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', e => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        uploadSection.addEventListener('dragleave', () => uploadSection.classList.remove('dragover'));
        uploadSection.addEventListener('drop', e => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            if (e.dataTransfer.files[0]) processFile(e.dataTransfer.files[0]);
        });

        function processFile(file) {
            document.getElementById('loading').classList.add('active');
            document.getElementById('errorMsg').classList.remove('active');
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const papers = parsePubMedData(e.target.result);
                    paperMeshNetwork = generatePaperMeshNetwork(papers);
                    coauthorshipNetwork = generateCoauthorshipNetwork(papers);
                    displayNetworks();
                    document.getElementById('loading').classList.remove('active');
                    document.getElementById('uploadSection').style.display = 'none';
                    document.getElementById('networkSection').style.display = 'block';
                    setupSearch();
                } catch (error) {
                    document.getElementById('errorMsg').textContent = 'Error: ' + error.message;
                    document.getElementById('errorMsg').classList.add('active');
                    document.getElementById('loading').classList.remove('active');
                }
            };
            reader.readAsText(file);
        }

        function parsePubMedData(data) {
            const papers = [];
            const entries = data.split('PMID-');
            for (let i = 1; i < entries.length; i++) {
                const entry = entries[i].trim();
                const lines = entry.split('\n');
                const paper = { journal: '', authors: [], meshTerms: [], pmid: '' };
                const pmidMatch = entry.match(/^(\d+)/);
                if (pmidMatch) { paper.pmid = pmidMatch[1]; }

                for (const line of lines) {
                    if (line.startsWith('JT  -')) paper.journal = line.replace('JT  -', '').trim();
                    else if (line.startsWith('FAU -')) {
                        const name = line.replace('FAU -', '').trim();
                        if (name.includes(',')) {
                            const [last, first] = name.split(',', 2);
                            const firstName = first.trim().split(' ')[0] || '';
                            paper.authors.push(firstName ? `${firstName} ${last.trim()}` : last.trim());
                        } else paper.authors.push(name);
                    } else if (line.startsWith('MH  -')) paper.meshTerms.push(line.replace('MH  -', '').trim().replace('*', ''));
                }

                if (paper.journal && paper.pmid && (paper.authors.length > 0 || paper.meshTerms.length > 0)) {
                    papers.push(paper);
                }
            }
            return papers;
        }

        function generatePaperMeshNetwork(papers) {
            const nodes = [], links = [], nodeMap = new Map();
            let nodeId = 0;
            papers.forEach(paper => {
                const journalLabel = `${paper.journal} [PMID:${paper.pmid}]`;
                if (!nodeMap.has(journalLabel)) {
                    nodeMap.set(journalLabel, nodeId);
                    nodes.push({ id: nodeId++, name: journalLabel, displayName: journalLabel, type: 'journal', degree: 0, pmid: paper.pmid });
                }
                paper.meshTerms.forEach(mesh => {
                    if (!nodeMap.has(mesh)) {
                        nodeMap.set(mesh, nodeId);
                        nodes.push({ id: nodeId++, name: mesh, displayName: mesh, type: 'mesh', degree: 0 });
                    }
                    const jId = nodeMap.get(journalLabel), mId = nodeMap.get(mesh);
                    links.push({ source: jId, target: mId });
                    nodes[jId].degree++; nodes[mId].degree++;
                });
            });
            return { nodes, links };
        }

        function generateCoauthorshipNetwork(papers) {
            const nodes = [], links = [], nodeMap = new Map(), collaborations = new Map();
            let nodeId = 0;
            papers.forEach(paper => {
                if (paper.authors.length < 2) return;
                paper.authors.forEach(author => {
                    if (!nodeMap.has(author)) {
                        nodeMap.set(author, nodeId);
                        nodes.push({ id: nodeId++, name: author, displayName: author, degree: 0, papers: 0 });
                    }
                    nodes[nodeMap.get(author)].papers++;
                });
                for (let i = 0; i < paper.authors.length; i++) {
                    for (let j = i + 1; j < paper.authors.length; j++) {
                        const pair = [paper.authors[i], paper.authors[j]].sort().join('|');
                        if (!collaborations.has(pair)) {
                            collaborations.set(pair, { source: nodeMap.get(paper.authors[i]), target: nodeMap.get(paper.authors[j]), weight: 0 });
                        }
                        collaborations.get(pair).weight++;
                    }
                }
            });
            collaborations.forEach(c => {
                links.push(c);
                nodes[c.source].degree++; nodes[c.target].degree++;
            });
            detectCommunities(nodes, links);
            return { nodes, links };
        }

        function detectCommunities(nodes, links) {
            const communities = new Map();
            nodes.forEach((n, i) => communities.set(n.id, i));
            const adj = new Map();
            nodes.forEach(n => adj.set(n.id, []));
            links.forEach(l => {
                const sId = typeof l.source === 'object' ? l.source.id : l.source;
                const tId = typeof l.target === 'object' ? l.target.id : l.target;
                adj.get(sId).push({ node: tId, weight: l.weight });
                adj.get(tId).push({ node: sId, weight: l.weight });
            });
            for (let iter = 0; iter < 10; iter++) {
                let improved = false;
                nodes.forEach(node => {
                    const curr = communities.get(node.id);
                    const neighbors = new Map();
                    adj.get(node.id).forEach(n => {
                        const c = communities.get(n.node);
                        neighbors.set(c, (neighbors.get(c) || 0) + n.weight);
                    });
                    let best = curr, bestScore = neighbors.get(curr) || 0;
                    neighbors.forEach((score, comm) => {
                        if (score > bestScore) { bestScore = score; best = comm; }
                    });
                    if (best !== curr) { communities.set(node.id, best); improved = true; }
                });
                if (!improved) break;
            }
            const unique = [...new Set(communities.values())];
            const map = new Map();
            unique.forEach((c, i) => map.set(c, i));
            nodes.forEach(n => n.community = map.get(communities.get(n.id)));
        }

        function highlightNode(nodeId, networkType) {
            const svg = networkType === 'paper-mesh' ? d3.select('#svgPaperMesh') : d3.select('#svgCoauthorship');
            const data = networkType === 'paper-mesh' ? paperMeshNetwork : coauthorshipNetwork;
            const connectedNodeIds = new Set([nodeId]);
            const connectedLinkIds = new Set();
            data.links.forEach((link, idx) => {
                const sourceId = link.source.id !== undefined ? link.source.id : link.source;
                const targetId = link.target.id !== undefined ? link.target.id : link.target;
                if (sourceId === nodeId || targetId === nodeId) {
                    connectedNodeIds.add(sourceId); connectedNodeIds.add(targetId); connectedLinkIds.add(idx);
                }
            });
            svg.selectAll('.node').classed('faded', d => !connectedNodeIds.has(d.id)).classed('highlighted', d => d.id === nodeId);
            svg.selectAll('.link').each(function (d, i) {
                d3.select(this).classed('faded', !connectedLinkIds.has(i)).classed('highlighted', connectedLinkIds.has(i));
            });
            svg.selectAll('text').classed('faded', d => !connectedNodeIds.has(d.id)).classed('highlighted', d => d.id === nodeId);
        }

        function clearHighlight(networkType) {
            const svg = networkType === 'paper-mesh' ? d3.select('#svgPaperMesh') : d3.select('#svgCoauthorship');
            svg.selectAll('.node').classed('faded', false).classed('highlighted', false);
            svg.selectAll('.link').classed('faded', false).classed('highlighted', false);
            svg.selectAll('text').classed('faded', false).classed('highlighted', false);
        }

        function clearSelection(networkType) {
            selectedNode[networkType] = null;
            clearHighlight(networkType);
        }

        function focusOnNode(nodeId, networkType) {
            const data = networkType === 'paper-mesh' ? paperMeshNetwork : coauthorshipNetwork;
            const node = data.nodes.find(n => n.id === nodeId);
            if (!node) return;
            const svg = networkType === 'paper-mesh' ? d3.select('#svgPaperMesh') : d3.select('#svgCoauthorship');
            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            const scale = 1.5;
            const x = width / 2 - node.x * scale;
            const y = height / 2 - node.y * scale;
            svg.transition().duration(750).call(d3.zoom().transform, d3.zoomIdentity.translate(x, y).scale(scale));
            selectedNode[networkType] = nodeId;
            highlightNode(nodeId, networkType);
        }

        function setupSearch() {
            const searchPM = document.getElementById('searchPaperMesh');
            const searchCA = document.getElementById('searchCoauthorship');
            const resultsPM = document.getElementById('searchResultsPaperMesh');
            const resultsCA = document.getElementById('searchResultsCoauthorship');
            searchPM.addEventListener('input', e => performSearch(e.target.value, 'paper-mesh', resultsPM));
            searchCA.addEventListener('input', e => performSearch(e.target.value, 'coauthorship', resultsCA));
            document.addEventListener('click', e => {
                if (!e.target.closest('.search-container')) {
                    resultsPM.classList.remove('show');
                    resultsCA.classList.remove('show');
                }
            });
        }

        function performSearch(query, networkType, resultsDiv) {
            if (!query.trim()) { resultsDiv.classList.remove('show'); return; }
            const data = networkType === 'paper-mesh' ? paperMeshNetwork : coauthorshipNetwork;
            const matches = data.nodes.filter(n => n.displayName.toLowerCase().includes(query.toLowerCase())).slice(0, 10);
            if (matches.length === 0) {
                resultsDiv.innerHTML = '<div class="no-results">No matches found</div>';
                resultsDiv.classList.add('show');
                return;
            }
            resultsDiv.innerHTML = matches.map(node => `<div class="search-result-item" onclick="selectSearchResult(${node.id},'${networkType}')">${node.displayName}</div>`).join('');
            resultsDiv.classList.add('show');
        }

        function selectSearchResult(nodeId, networkType) {
            focusOnNode(nodeId, networkType);
            const resultsDiv = networkType === 'paper-mesh' ? document.getElementById('searchResultsPaperMesh') : document.getElementById('searchResultsCoauthorship');
            resultsDiv.classList.remove('show');
            const searchInput = networkType === 'paper-mesh' ? document.getElementById('searchPaperMesh') : document.getElementById('searchCoauthorship');
            searchInput.value = '';
        }

        function displayNetworks() {
            displayPaperMeshNetwork();
            displayCoauthorshipNetwork();
            updateStats();
        }

        function displayPaperMeshNetwork() {
            const svg = d3.select('#svgPaperMesh');
            svg.selectAll('*').remove();
            const container = svg.node().parentElement;
            const width = container.clientWidth, height = container.clientHeight;
            const g = svg.append('g');
            const simulation = d3.forceSimulation(paperMeshNetwork.nodes)
                .force('link', d3.forceLink(paperMeshNetwork.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            const link = g.append('g').selectAll('line').data(paperMeshNetwork.links).join('line')
                .attr('class', 'link').attr('stroke-width', 1.5);
            const node = g.append('g').selectAll('circle').data(paperMeshNetwork.nodes).join('circle')
                .attr('class', 'node')
                .attr('r', d => Math.sqrt(d.degree) * currentNodeSize['paper-mesh'] + 8)
                .attr('fill', d => d.type === 'journal' ? journalColor : meshColor)
                .call(d3.drag()
                    .on('start', e => { if (!e.active) simulation.alphaTarget(0.3).restart(); e.subject.fx = e.subject.x; e.subject.fy = e.subject.y; })
                    .on('drag', e => { e.subject.fx = e.x; e.subject.fy = e.y; })
                    .on('end', e => { if (!e.active) simulation.alphaTarget(0); e.subject.fx = null; e.subject.fy = null; }));

            node.on('mouseenter', (e, d) => {
                if (selectedNode['paper-mesh'] === null) { highlightNode(d.id, 'paper-mesh'); }
                let html = `<strong>${d.displayName}</strong><div class="tooltip-text">Type: ${d.type === 'journal' ? 'Journal' : 'MeSH'}<br/>Connections: ${d.degree}`;
                if (d.type === 'journal' && d.pmid) { html += `<br/><br/><span style="color:var(--accent);">Click to view on PubMed</span>`; }
                html += `</div>`;
                document.getElementById('tooltip').innerHTML = html;
                document.getElementById('tooltip').style.left = (e.pageX + 10) + 'px';
                document.getElementById('tooltip').style.top = (e.pageY - 10) + 'px';
                document.getElementById('tooltip').classList.add('show');
            }).on('mouseleave', () => {
                if (selectedNode['paper-mesh'] === null) { clearHighlight('paper-mesh'); }
                document.getElementById('tooltip').classList.remove('show');
            }).on('click', (e, d) => {
                e.stopPropagation();
                selectedNode['paper-mesh'] = d.id;
                highlightNode(d.id, 'paper-mesh');
                if (d.type === 'journal' && d.pmid) { window.open(`https://pubmed.ncbi.nlm.nih.gov/${d.pmid}/`, '_blank'); }
            });
            const label = g.append('g').selectAll('text').data(paperMeshNetwork.nodes).join('text')
                .text(d => { if (d.displayName.length > 50) return d.displayName.substring(0, 50) + '...'; return d.displayName; })
                .attr('font-size', d => Math.max(8, Math.sqrt(d.degree) * currentNodeSize['paper-mesh'] / 2 + 6));

            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('cx', d => d.x).attr('cy', d => d.y);
                label.attr('x', d => d.x).attr('y', d => d.y);
            });
            svg.call(d3.zoom().scaleExtent([0.1, 4]).on('zoom', e => g.attr('transform', e.transform)));
            svg.on('click', function (e) { if (e.target === this) { clearSelection('paper-mesh'); } });
            paperMeshSimulation = simulation;
        }

        function displayCoauthorshipNetwork() {
            const svg = d3.select('#svgCoauthorship');
            svg.selectAll('*').remove();
            const container = svg.node().parentElement;
            const width = container.clientWidth, height = container.clientHeight;
            const g = svg.append('g');
            const simulation = d3.forceSimulation(coauthorshipNetwork.nodes)
                .force('link', d3.forceLink(coauthorshipNetwork.links).id(d => d.id).distance(d => 120 / Math.sqrt(d.weight)))
                .force('charge', d3.forceManyBody().strength(-400))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(35));
            const link = g.append('g').selectAll('line').data(coauthorshipNetwork.links).join('line')
                .attr('class', 'link').attr('stroke-width', d => Math.sqrt(d.weight) * 2);
            const node = g.append('g').selectAll('circle').data(coauthorshipNetwork.nodes).join('circle')
                .attr('class', 'node')
                .attr('r', d => Math.sqrt(d.degree) * currentNodeSize['coauthorship'] + 10)
                .attr('fill', d => communityColors[d.community % communityColors.length])
                .call(d3.drag()
                    .on('start', e => { if (!e.active) simulation.alphaTarget(0.3).restart(); e.subject.fx = e.subject.x; e.subject.fy = e.subject.y; })
                    .on('drag', e => { e.subject.fx = e.x; e.subject.fy = e.y; })
                    .on('end', e => { if (!e.active) simulation.alphaTarget(0); e.subject.fx = null; e.subject.fy = null; }));

            node.on('mouseenter', (e, d) => {
                if (selectedNode['coauthorship'] === null) { highlightNode(d.id, 'coauthorship'); }
                const searchName = d.name.replace(/ /g, '+');
                const html = `<strong>${d.displayName}</strong><div class="tooltip-text">Community: ${d.community + 1}<br/>Collaborations: ${d.degree}<br/>Papers: ${d.papers}<br/><br/><span style="color:var(--accent);">Click to search on PubMed</span></div>`;
                document.getElementById('tooltip').innerHTML = html;
                document.getElementById('tooltip').style.left = (e.pageX + 10) + 'px';
                document.getElementById('tooltip').style.top = (e.pageY - 10) + 'px';
                document.getElementById('tooltip').classList.add('show');
            }).on('mouseleave', () => {
                if (selectedNode['coauthorship'] === null) { clearHighlight('coauthorship'); }
                document.getElementById('tooltip').classList.remove('show');
            }).on('click', (e, d) => {
                e.stopPropagation();
                selectedNode['coauthorship'] = d.id;
                highlightNode(d.id, 'coauthorship');
                const searchName = d.name.replace(/ /g, '+');
                window.open(`https://pubmed.ncbi.nlm.nih.gov/?term=${searchName}`, '_blank');
            });
            const label = g.append('g').selectAll('text').data(coauthorshipNetwork.nodes).join('text')
                .text(d => d.displayName)
                .attr('font-size', d => Math.max(8, Math.sqrt(d.degree) * currentNodeSize['coauthorship'] / 1.5 + 7));

            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('cx', d => d.x).attr('cy', d => d.y);
                label.attr('x', d => d.x).attr('y', d => d.y);
            });
            svg.call(d3.zoom().scaleExtent([0.1, 4]).on('zoom', e => g.attr('transform', e.transform)));
            svg.on('click', function (e) { if (e.target === this) { clearSelection('coauthorship'); } });
            coauthorshipSimulation = simulation;

            const communities = [...new Set(coauthorshipNetwork.nodes.map(n => n.community))].sort((a, b) => a - b);
            document.getElementById('communityLegend').innerHTML = communities.map(c => {
                const count = coauthorshipNetwork.nodes.filter(n => n.community === c).length;
                const color = communityColors[c % communityColors.length];
                return `<div class="legend-item"><div class="legend-color" style="background: ${color};"></div><span>Comm. ${c + 1} (${count})</span></div>`;
            }).join('');
        }

        function updateStats() {
            const journals = paperMeshNetwork.nodes.filter(n => n.type === 'journal').length;
            const meshTerms = paperMeshNetwork.nodes.filter(n => n.type === 'mesh').length;
            document.getElementById('statsPaperMesh').innerHTML = `<div class="stat-card"><div class="stat-value">${journals}</div><div class="stat-label">Journals</div></div><div class="stat-card"><div class="stat-value">${meshTerms}</div><div class="stat-label">MeSH Terms</div></div><div class="stat-card"><div class="stat-value">${paperMeshNetwork.links.length}</div><div class="stat-label">Connections</div></div>`;
            const numCommunities = new Set(coauthorshipNetwork.nodes.map(n => n.community)).size;
            document.getElementById('statsCoauthorship').innerHTML = `<div class="stat-card"><div class="stat-value">${coauthorshipNetwork.nodes.length}</div><div class="stat-label">Authors</div></div><div class="stat-card"><div class="stat-value">${coauthorshipNetwork.links.length}</div><div class="stat-label">Collaborations</div></div><div class="stat-card"><div class="stat-value">${numCommunities}</div><div class="stat-label">Communities</div></div>`;
        }

        function switchNetwork(networkType) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.network-container').forEach(c => c.classList.remove('active'));
            document.getElementById(networkType).classList.add('active');
        }

        function resetZoom(networkType) {
            const svg = networkType === 'paper-mesh' ? d3.select('#svgPaperMesh') : d3.select('#svgCoauthorship');
            svg.transition().duration(750).call(d3.zoom().transform, d3.zoomIdentity.translate(0, 0).scale(1));
            if (networkType === 'paper-mesh') paperMeshSimulation.alpha(1).restart();
            else coauthorshipSimulation.alpha(1).restart();
        }

        function downloadNetwork(networkType) {
            try {
                if (typeof XLSX === 'undefined') { alert('Excel library not loaded'); return; }
                const data = networkType === 'paper-mesh' ? paperMeshNetwork : coauthorshipNetwork;
                const rows = networkType === 'paper-mesh' ? [['Source', 'Target', 'Type', 'Source Type', 'Target Type', 'PMID']] : [['Source', 'Target', 'Weight', 'Source Community', 'Target Community']];
                data.links.forEach(link => {
                    const sId = link.source.id !== undefined ? link.source.id : link.source;
                    const tId = link.target.id !== undefined ? link.target.id : link.target;
                    const s = data.nodes.find(n => n.id === sId);
                    const t = data.nodes.find(n => n.id === tId);
                    if (s && t) {
                        if (networkType === 'paper-mesh') rows.push([s.name, t.name, 'Undirected', s.type === 'journal' ? 'Journal' : 'MeSH', t.type === 'journal' ? 'Journal' : 'MeSH', s.pmid || '']);
                        else rows.push([s.name, t.name, link.weight, s.community + 1, t.community + 1]);
                    }
                });
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(rows);
                XLSX.utils.book_append_sheet(wb, ws, networkType === 'paper-mesh' ? 'Paper-MeSH' : 'Coauthorship');
                XLSX.writeFile(wb, `${networkType}_network_${new Date().toISOString().split('T')[0]}.xlsx`);
            } catch (error) { alert('Download error: ' + error.message); }
        }

        document.getElementById('nodeSizePaperMesh').addEventListener('input', e => {
            currentNodeSize['paper-mesh'] = parseFloat(e.target.value);
            document.getElementById('nodeSizeValuePM').textContent = e.target.value;
            displayPaperMeshNetwork();
        });
        document.getElementById('nodeSizeCoauthorship').addEventListener('input', e => {
            currentNodeSize['coauthorship'] = parseFloat(e.target.value);
            document.getElementById('nodeSizeValueCA').textContent = e.target.value;
            displayCoauthorshipNetwork();
        });
        document.getElementById('layoutPaperMesh').addEventListener('change', e => {
            if (e.target.value === 'circular') {
                const nodes = paperMeshNetwork.nodes;
                const radius = 250, angleStep = (2 * Math.PI) / nodes.length;
                nodes.forEach((n, i) => {
                    const angle = i * angleStep;
                    n.fx = 300 + radius * Math.cos(angle);
                    n.fy = 300 + radius * Math.sin(angle);
                });
                paperMeshSimulation.alpha(0.3).restart();
                setTimeout(() => nodes.forEach(n => { n.fx = null; n.fy = null; }), 2000);
            } else displayPaperMeshNetwork();
        });
        document.getElementById('layoutCoauthorship').addEventListener('change', e => {
            if (e.target.value === 'circular') {
                const nodes = coauthorshipNetwork.nodes;
                const radius = 250, angleStep = (2 * Math.PI) / nodes.length;
                nodes.forEach((n, i) => {
                    const angle = i * angleStep;
                    n.fx = 300 + radius * Math.cos(angle);
                    n.fy = 300 + radius * Math.sin(angle);
                });
                coauthorshipSimulation.alpha(0.3).restart();
                setTimeout(() => nodes.forEach(n => { n.fx = null; n.fy = null; }), 2000);
            } else displayCoauthorshipNetwork();
        });
        document.getElementById('minWeight').addEventListener('input', e => {
            document.getElementById('minWeightValue').textContent = e.target.value;
            const minW = parseInt(e.target.value);
            const filteredLinks = coauthorshipNetwork.links.filter(l => l.weight >= minW);
            const connectedIds = new Set();
            filteredLinks.forEach(l => {
                connectedIds.add(l.source.id || l.source);
                connectedIds.add(l.target.id || l.target);
            });
            const filteredNodes = coauthorshipNetwork.nodes.filter(n => connectedIds.has(n.id));
            const temp = coauthorshipNetwork;
            coauthorshipNetwork = { nodes: filteredNodes, links: filteredLinks };
            displayCoauthorshipNetwork();
            coauthorshipNetwork = temp;
        });
    </script>
</body>

</html>